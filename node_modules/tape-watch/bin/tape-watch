#!/usr/bin/env node
var chokidar = require('chokidar')
var debounce = require('debounce-collect')
var path = require('path')
var once = require('once')
var debug = require('debug')('tape-watch')
var mutex = require('../lib/mutex')
var wait = require('../lib/wait')
var stream = require('stream')

var cli = require('meow')([
  'Usage:',
  '  $ tape-watch [file] [options] -- [options for the test]',
  '',
  'Options:',
  '  -p, --pipe PACKAGE        pipe to this package',
  '  -o, --out CMD             output to this file/cmd',
  '  -r, --refresh PACKAGE     ensure this PACKAGE gets refreshed',
  '',
  'Other options:',
  '  -h, --help                show usage information',
  '  -v, --version             print version info and exit',
  '',
  'Examples:',
  '  tape-watch test/index.js',
  '  tape-watch test/index.js -p tap-spec',
  '  tape-watch test/index.js -o "| tap-spec --color"',
  '',
  '  # ensure require("jquery") always gets reevaluated',
  '  tape-watch test/index.js -r jquery',
].join('\n'), {
  boolean: ['help', 'version'],
  string: ['pipe', 'out', 'refresh'],
  '--': true,
  alias: {
    h: 'help', v: 'version', p: 'pipe', o: 'out', r: 'refresh'
  }
})

var filename = cli.input[0]
var cwd = process.cwd()
process.argv = cli.input.slice(1)

var report = debounce(mutex(function (files) {
  debug('start', files.map(function (file) { return file[0] }))

  return invoke()
    .then(function (ok) {
      debug('done')
    })
    .catch(function (err) {
      debug('error')
      console.error(err.stack || err.message || err)
    })
    .then(function () {
      // cleanup
    })
    .then(wait(250))
    .then(function () {
      debug('listening again')
    })
}), 25)

/*
 * invoke the test. installs a tape hook to listen for when tests finish.
 */

var invoke = function () {
  return new Promise (function (resolve, reject) {
    flush()
    var stream = tape().createStream()

    if (cli.flags.pipe) {
      stream = stream.pipe(
        requireHere(cli.flags.pipe)())
    }

    if (cli.flags.out) {
      stream = stream.pipe(require('outpipe')(cli.flags.out))
    }

    stream.pipe(process.stdout)
    tape().onFinish(once(function () {
      debug('tape finished')
      tape().getHarness().close()
      resolve()
    }))
    debug('requiring')
    require(path.join(cwd, filename))
    debug('requiring done')
  })
}

function requireHere (pkg) {
  return require(path.join(cwd, 'node_modules', pkg))
}

function tape () {
  return requireHere('tape')
}

/*
 * delete require cache for any app code (non-modules) and tape itself.
 * we need to clear out tape so that its state is reset.
 */

function flush () {
  Object.keys(require.cache).forEach((function (fname) {
    if (fname.indexOf('node_modules') === -1) {
      delete require.cache[fname]
    }

    var mods = ['tape'].concat(toArray(cli.flags.refresh))
    mods.forEach(function (mod) {
      if (fname.indexOf(path.join(cwd, mod) + path.sep) > -1 ||
        fname.indexOf(path.join(cwd, 'node_modules', mod) + path.sep) > -1) {
        delete require.cache[fname]
      }
    })
  }))
}

function toArray (list) {
  if (!list) return []
  return Array.isArray(list) ? list : [ list ]
}

process.on('uncaughtException', function (err) {
  console.error(err.stack || err.message || err)
})

var watcher = chokidar.watch('.', {
  ignored: /[\/\\]\.|node_modules/,
  persistent: true,
  ignoreInitial: true
})

watcher.on('change', report)
watcher.on('add', report)
watcher.on('unlink', report)
report()
